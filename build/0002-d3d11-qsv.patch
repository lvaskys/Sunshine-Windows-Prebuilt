From 776d5a747220b03810c7d7a02f1c41c800316799 Mon Sep 17 00:00:00 2001
From: Artem Galin <artem.galin@intel.com>
Date: Fri, 20 Aug 2021 22:48:02 +0100
Subject: [PATCH] libavcodec/qsv: enabling d3d11va support, added mfxhdlpair

Adding DX11 relevant device type checks and adjusting callbacks with
proper MediaSDK pair type support.

Extending structure for proper MediaSDK pair type support.

Signed-off-by: Artem Galin <artem.galin@intel.com>
---
 libavcodec/qsv.c          | 53 ++++++++++++++++++++++++++-------------
 libavcodec/qsv_internal.h |  2 +-
 2 files changed, 37 insertions(+), 18 deletions(-)

diff --git a/libavcodec/qsv.c b/libavcodec/qsv.c
index c53e2e3b07ac..139c4971de9d 100644
--- a/libavcodec/qsv.c
+++ b/libavcodec/qsv.c
@@ -36,6 +36,8 @@
 #include "avcodec.h"
 #include "qsv_internal.h"
 
+#define MFX_IMPL_VIA_MASK(impl) (0x0f00 & (impl))
+
 #if QSV_VERSION_ATLEAST(1, 12)
 #include "mfx/mfxvp8.h"
 #endif
@@ -230,7 +232,9 @@ int ff_qsv_find_surface_idx(QSVFramesContext *ctx, QSVFrame *frame)
     int i;
     for (i = 0; i < ctx->nb_mids; i++) {
         QSVMid *mid = &ctx->mids[i];
-        if (mid->handle == frame->surface.Data.MemId)
+        mfxHDLPair *pair = (mfxHDLPair*)frame->surface.Data.MemId;
+        if ((mid->handle_pair->first == pair->first) &&
+            (mid->handle_pair->second == pair->second))
             return i;
     }
     return AVERROR_BUG;
@@ -370,7 +374,11 @@ static int ff_qsv_set_display_handle(AVCodecContext *avctx, QSVSession *qs)
 int ff_qsv_init_internal_session(AVCodecContext *avctx, QSVSession *qs,
                                  const char *load_plugins, int gpu_copy)
 {
+#if CONFIG_D3D11VA
+    mfxIMPL          impl = MFX_IMPL_AUTO_ANY | MFX_IMPL_VIA_D3D11;
+#else
     mfxIMPL          impl = MFX_IMPL_AUTO_ANY;
+#endif
     mfxVersion        ver = { { QSV_VERSION_MINOR, QSV_VERSION_MAJOR } };
     mfxInitParam init_par = { MFX_IMPL_AUTO_ANY };
 
@@ -459,7 +467,7 @@ static AVBufferRef *qsv_create_mids(AVBufferRef *hw_frames_ref)
 
     for (i = 0; i < nb_surfaces; i++) {
         QSVMid *mid = &mids[i];
-        mid->handle        = frames_hwctx->surfaces[i].Data.MemId;
+        mid->handle_pair   = (mfxHDLPair*)frames_hwctx->surfaces[i].Data.MemId;
         mid->hw_frames_ref = hw_frames_ref1;
     }
 
@@ -636,7 +644,7 @@ static mfxStatus qsv_frame_lock(mfxHDL pthis, mfxMemId mid, mfxFrameData *ptr)
         goto fail;
 
     qsv_mid->surf.Info = hw_frames_hwctx->surfaces[0].Info;
-    qsv_mid->surf.Data.MemId = qsv_mid->handle;
+    qsv_mid->surf.Data.MemId = qsv_mid->handle_pair;
 
     /* map the data to the system memory */
     ret = av_hwframe_map(qsv_mid->locked_frame, qsv_mid->hw_frame,
@@ -669,7 +677,13 @@ static mfxStatus qsv_frame_unlock(mfxHDL pthis, mfxMemId mid, mfxFrameData *ptr)
 static mfxStatus qsv_frame_get_hdl(mfxHDL pthis, mfxMemId mid, mfxHDL *hdl)
 {
     QSVMid *qsv_mid = (QSVMid*)mid;
-    *hdl = qsv_mid->handle;
+    mfxHDLPair *pair_dst = (mfxHDLPair*)hdl;
+    mfxHDLPair *pair_src = (mfxHDLPair*)qsv_mid->handle_pair;
+
+    pair_dst->first = pair_src->first;
+
+    if (pair_src->second != (mfxMemId)MFX_INFINITE)
+        pair_dst->second = pair_src->second;
     return MFX_ERR_NONE;
 }
 
@@ -677,24 +691,19 @@ int ff_qsv_init_session_device(AVCodecContext *avctx, mfxSession *psession,
                                AVBufferRef *device_ref, const char *load_plugins,
                                int gpu_copy)
 {
-    static const mfxHandleType handle_types[] = {
-        MFX_HANDLE_VA_DISPLAY,
-        MFX_HANDLE_D3D9_DEVICE_MANAGER,
-        MFX_HANDLE_D3D11_DEVICE,
-    };
     AVHWDeviceContext    *device_ctx = (AVHWDeviceContext*)device_ref->data;
     AVQSVDeviceContext *device_hwctx = device_ctx->hwctx;
     mfxSession        parent_session = device_hwctx->session;
     mfxInitParam            init_par = { MFX_IMPL_AUTO_ANY };
     mfxHDL                    handle = NULL;
+    int          hw_handle_supported = 0;
 
     mfxSession    session;
     mfxVersion    ver;
     mfxIMPL       impl;
     mfxHandleType handle_type;
     mfxStatus err;
-
-    int i, ret;
+    int ret;
 
     err = MFXQueryIMPL(parent_session, &impl);
     if (err == MFX_ERR_NONE)
@@ -703,13 +712,23 @@ int ff_qsv_init_session_device(AVCodecContext *avctx, mfxSession *psession,
         return ff_qsv_print_error(avctx, err,
                                   "Error querying the session attributes");
 
-    for (i = 0; i < FF_ARRAY_ELEMS(handle_types); i++) {
-        err = MFXVideoCORE_GetHandle(parent_session, handle_types[i], &handle);
-        if (err == MFX_ERR_NONE) {
-            handle_type = handle_types[i];
-            break;
+    if (MFX_IMPL_VIA_VAAPI == MFX_IMPL_VIA_MASK(impl)) {
+        handle_type = MFX_HANDLE_VA_DISPLAY;
+        hw_handle_supported = 1;
+    } else if (MFX_IMPL_VIA_D3D11 == MFX_IMPL_VIA_MASK(impl)) {
+        handle_type = MFX_HANDLE_D3D11_DEVICE;
+        hw_handle_supported = 1;
+    } else if (MFX_IMPL_VIA_D3D9 == MFX_IMPL_VIA_MASK(impl)) {
+        handle_type = MFX_HANDLE_D3D9_DEVICE_MANAGER;
+        hw_handle_supported = 1;
+    }
+
+    if (hw_handle_supported) {
+        err = MFXVideoCORE_GetHandle(parent_session, handle_type, &handle);
+        if (err != MFX_ERR_NONE) {
+            return ff_qsv_print_error(avctx, err,
+                                  "Error getting handle session");
         }
-        handle = NULL;
     }
     if (!handle) {
         av_log(avctx, AV_LOG_VERBOSE, "No supported hw handle could be retrieved "
diff --git a/libavcodec/qsv_internal.h b/libavcodec/qsv_internal.h
index 327a8d338594..6b96c413c5c9 100644
--- a/libavcodec/qsv_internal.h
+++ b/libavcodec/qsv_internal.h
@@ -62,7 +62,7 @@
 
 typedef struct QSVMid {
     AVBufferRef *hw_frames_ref;
-    mfxHDL handle;
+    mfxHDLPair *handle_pair;
 
     AVFrame *locked_frame;
     AVFrame *hw_frame;
